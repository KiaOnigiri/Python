#pip install {название}(numpy,pandas,matplotlib) (в командную строку)
import numpy as np
'import pandas as pd'
'import matplotlib as plt'
#-----ГАЙД ПО NUMPY-----
'Во-первых, давай разберёмся о том, для чего эта библиотека вообще нужна'
'Эта библиотека может значительно ускорить любую вычислительную операцию питон связанную со списками'
'Она предоставляет юзеру свои списки, и именно эти списки называются массивами'
'Также, кроме дополнительных списков, имеет ряд атрибутов, которых нет в стандартном питоне, что не только ускоряет работу с массивами, но и сильно её упрощает'
'И так, вот сам гайд'
'Предупреждение: библиотека непростая, не всё ты сможешь разобрать сам, но в то же время очень полезная, очень многие её используют'
ma=np.array([1,3,6])#создаёт самый простой одномерный массив
print(ma)
#МЕТОДЫ, КОТОРЫЕ ПРИМЕНЯЮТСЯ К МАССИВАМ ЛЮБОГО ТИПА
#.ndim - количество осей (списков в других списках), применяется к массивам
#.shape - сколько элементов в каждой оси, применяется к массивам
#.size - сколько всего элементов в сумме, применяется к массивам
#.dtype - в каком типе данных выводится (также число означает степень двойки, максимальное число, которое можно записать (Пример: Тип данных int8, значит максимальное число в этом формате 255(256-1, 256=2**8))), применяется к массивам
#.itemsize - сколько памяти в байтах занимает один элемент массива, применяется к массивам
print(ma.dtype)
print(ma.ndim)
#к массивам можно дописать ,dtype="*Тип данных*", чтобы самостоятельно изменить его тип данных
#--ДАЛЬШЕ ПОЙДУТ ПРОСТО ДРУГИЕ ТИПЫ МАССИВОВ--
#np.zeros((высота, длина)) - создаёт уже двумерный массив, который состоит из нулей
doublema=np.zeros((5,6))
print('{} - двумерный массив из нулей'.format(doublema))
#np.ones((высота, длина)) - то же, что и с нулями, но с единицами
#np.eye(высота, длина) - да, тут уже скобочки почему-то одинарные, создаёт двумерный массив из единиц и нулей, где единицы идут только от левого верхнего угла к правому нижнему
#пока что не знаю то, для чего можно использовать np.eye(), поэтому можно не читать пока что
diagonallyma=np.eye(5,6)
print(f'{diagonallyma} - диагональный двумерный массив')
#np.arange(от какого элемента (необязательно), до какого элемента, шаг (необязательно)) - очень полезная вещь, создаёт массив из чисел по порядку, но сразу в массиве, закрывает надобность в цикле
coolma=np.arange(1,10,2)
print('{} - массив arange'.format(coolma))
#np.linspace(от какого элемента (необязательно), до какого элемента, количество (не уверен)) - по типу arange, но вместо шага тут количество, оно указывает сколько элементов будет в массиве и сама создаёт недостающие с равной периодичностью между ними
maybecoolma=np.linspace(1,10,8)
print('{} - массив linspace'.format(maybecoolma))
#--ТЕПЕРЬ СНОВА ЧУТЬ-ЧУТЬ МЕТОДОВ К МАССИВАМ, НО УЖЕ МЕГАКРУТЫМ И СЛОЖНЫМ--
#.reshape((высота, длина)) - двойные скобочки, применяется к двумерным массивам, изменяет их мерность))))) (Примечание: Общая сумма элементов массива не должна изменяться)
FrstMa=np.ones((5,4))
print(f'{FrstMa} - до изменений')
FrstMa=FrstMa.reshape((2,10))#главное не забыть вот так присвоить, так нужно с любыми методами
print(f'{FrstMa} - после изменений, обычный двумерный массив')
#.resize(.reshape)((высота, длина, ширина)) - херня не работает, но вместо этого можно также использовать reshape и работает также, как и должно было при resize, при вводе третьего параметра изменяет размерность массива, сумма всех элементов не должна меняться
#вместо третьего параметра можно поставить -1 и он за вас досчитает сколько нужно подставить
ScndMa=np.ones((6,4))
print(f'{ScndMa} - до изменений')
ScndMa=ScndMa.reshape((2,4,3))
print(f'{ScndMa} - после изменений, трёхмерный массив')
#--ТЕПЕРЬ САМОЕ ИНТЕРЕСНОЕ)))))))))--
#эти массивы можно вычитать, прибавлять, делить, умножать друг с другом
Onee=np.array([1,6,9])
Scndd=np.array([2,3,4])
print(Onee + Scndd)
print(Onee - Scndd)
print(Onee * Scndd)
print(Onee / Scndd)
print('Операции с двумя одномерными массивами')
#Можно перемножить два двумерный массива с помощью @, но там всё чуточку сложнее.....
#Пример с буквами, как это работает: Frst=[[a,b],[c,d]] Scnd=[[e,f],[g,h]] Результат: [[a*e+c*g,a*f+c*h],[b*e+d*g,b*f+d*h]]
Frst=np.array([[1,2],[2,3]])
Scnd=np.array([[4,5],[6,7]])
Result=Frst@Scnd
print(f'Умножение будет равно {Result}')
#Штучки с поворотом массива
YaZadolbalsya= np.arange(1, 13).reshape(4, 3)
print(YaZadolbalsya)
print("Транспонирование")#Меняет в решейпе местами высоту и длину массива
print(YaZadolbalsya.transpose())
YaZadolbalsya=YaZadolbalsya.transpose()
print("Поворот вправо")#Поворачивает массив на 90 градусов вправо))))
print(np.rot90(YaZadolbalsya))
print("Поворот влево")#Поворачивает массив на 90 градусов влево))))
print(np.rot90(YaZadolbalsya, -1))
#Ещё одна удобная функция то, что абсолютно все элементы, даже из разных подмассивов можно суммировать, вычислить максимум и минимум, у обычных такого нет
Ahhh=np.array([[1,2,3],[4,5,6],[7,8,9]])
print(f'Изнач массив{Ahhh}')
print(f'Сумма {Ahhh.sum()}')
print(f'Максимум {Ahhh.max()}')
print(f'Минимум {Ahhh.min()}')
#Также это всё можно отдельно сделать по столбцам и строкам
Ah=np.array([[1, 2, 3],[4, 5, 6],[7, 8, 9]])
print(f'Изначальный массив{Ah}')
print(f'Сумма по столбцам{Ah.sum(axis=0)}')  # сумма чисел в каждом столбце
print(f'Сумма по строкам{Ah.sum(axis=1)}')  # сумма чисел в каждой строке
print(f'Минимум по столбцам{Ah.min(axis=0)}')  # минимум по столбцам
print(f'Максимум по строкам{Ah.max(axis=1)}')  # максимум по строкам
#Следующее, скорее всего, будет  самой интересной штукой из всех, срезы по двумерным массивам))))))
Ahaha=np.arange(1, 13).reshape(3, 4)
#Ahaha[срез по высоте, срез по длине], работает, как обычные срезы, но в двумерном формате, как в обычных срезах можно указывать шаг, по высоте и по длине
print(f'Изначальный массивввв{Ahaha}')
print(f'Срез 1{Ahaha[:2,2:]}')
print(f'Срез 2{Ahaha[:,::2]}')
#Поздравляю, ты почти изучил numpy, последнее довольно простое, .flat, которое последовательно возвращает элементы массива, также работает из разных подмассивов
a = np.arange(1, 13).reshape(3, 4)
print('{} - заданный двумерный массив'.format(a))
print()
print(f'Вывод элементов: {"; ".join(str(el) for el in a.flat)}')
